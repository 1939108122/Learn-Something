当浏览器的网络进程收到HTML文档后，会产生一个渲染任务，会传递给渲染主线程的消息队列，在事件循环的机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染进程。

**整个过程分为以下几步：HTML解析、样式计算、布局、分层、绘制**

### HTML解析

解析过程中遇到CSS解析CSS，遇到JS执行JS,为了提高解析效率，浏览器会启动一个预解析线程率先下载HTML中的外部CSS和JS文件。如果主线程解析到**link** 位置，此时外部的CSS还没有下载好，主线程不会等待，会继续解析后面的HTML,这是因为下载和解析CSS的工作是在预解析线程中进行的，这就是为什么CSS不会阻塞HTML的解析的原因。


如果主线程解析到 **script** 位置,那么就会暂停解析HTML，会将JS下载运行完成后接着解析，因为JS代码可能会修改DOM结构，所以必须先执行JS, 这就是JS为什么会阻塞HTML的解析原因（js可以加上defer或者async）

解析完成后会得到DOM树和CSSOM树。

#### HTML解析过程中，遇到CSS代码怎么办？

为了提高解析效率，浏览器会启动一个预解析线程率先下载(网络进程下载)和解析CSS





### 样式计算（生成渲染树）

主线程遍历得到的DOM树，依次为树中的每个节点计算出它最终的样式，称之为computed style。

在这一过程中，预设值会变成绝对值，red变为rgb(255, 0, 0),相对单位变为绝对单位，em变为px。

这一步之后，会得到一颗带有样式的dom树称之为渲染树





### 布局

布局阶段会依次遍历渲染树的每个节点，计算出每个节点的几何信息，包括节点的尺寸和位置。


渲染树和布局树并非一一对应。

比如 display: none（head元素）在渲染树中，但是由于没有几何信息，不会出现在布局树中，比如伪元素不会在渲染树中，但是有几何信息就会出现在布局树中。


### 分层   

主线程会使用一套策略对整个布局树进行分层。

分层的好处在于，将来某一个层改变时，仅对该层进行后续处理，从而提升效率。

滚动条、堆叠上下文、transform、opacity等样式都会或多或少的影响分层结果，也可以通过will-change属性更大程度的影响分层结果。



### 绘制

主线程会为每个图层单独产生绘制指令，用于描述这一层该怎么画出来。

主线程将每个图层的绘制信息交给合成线程，剩余工作将由合成线程完成。
合成线程首先对每个图层进行分块，将其划分为更多的小区域。

分块完成后，进入光栅化阶段。

合成线程会将块信息交给GPU进程，以极高的速度完成光栅化。

GPU进程会开启多个线程来完成光栅化，并且优先处理靠近视口的块，最终结果是一块一块的视图。

最终就是画

合成线程拿到每个图层、每个块的位图后，生成一个个指引信息。
指引信息会标志出每个位图应该画到屏幕的哪个位置，以及考虑到旋转、缩放等，变形发生在合成线程中，与渲染主线程无关，所以这就是transform效率高的本质原因。
合成信息把指引信息提交给GPU进程，根据系统硬件完成最终的屏幕成像。





#### 什么是reflow？(重排)

当改变了元素的几何尺寸或者位置时，会引起重排。本质就是重新计算 布局树。
重排必然引起重绘。




#### 什么是repaint？(重绘)

当元素的属性不影响渲染树的布局，需要重新绘制就叫重绘。

repaint的本质就是重新根据分层信息产生绘制指令。 

比如：改变元素的背景颜色、outline、visibility、text-decoration、box-shadow等