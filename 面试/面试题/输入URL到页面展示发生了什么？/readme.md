1：缓存判断
2：DNS查询
3：获取MAC地址
4：TCP三次握手
5：HTTPS的TLS四次握手
6：发送HTTP请求
7：服务器处理请求并返回HTTP报文
8：渲染页面
9：断开连接





##### 一：缓存判断

浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里且没有失效，那么就直接使用，否则向服务器发起新的请求。



##### 二：DNS查询

DNS查询就是域名解析，根据域名查找到对应的IP地址。

以 www.baidu.com为例子：

1：浏览器会先查看自身有没有对这个域名的缓存，有则返回；

2：浏览器中没有缓存再去问操作系统缓存中是否有对这个域名的缓存，有则返回；

3：操作系统中没有缓存则再去 hosts 文件中查找，有则返回；

4：hosts 文件中也没有时才会再去问本地域名服务器

5: 本地域名服务器会先看自身有没有 www.baidu.com 对应 IP,有则返回；

6: 去根域名服务器 . 询问域名的IP;

7: 根域名服务器让本地域名服务器去问 .com服务器；

8: .com服务器让本地域名服务器去问 baidu.com服务器；

9: baidu.com服务器把对应的IP地址发给他；

10: 本地域名服务器将IP发给浏览器并放到缓存中。





##### 三：获取MAC地址

当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相结合，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。






##### 四：TCP三次握手




重要字段
```js
seq(sequence number): 序列号/顺序号；用来表示 TCP 发起端向接收端发送的字节流，发起端发送数据时对此进行标记。（可以理解为发送自己的数据）
ack(acknowledgement number): 确认号；只有 ACK 标志位存在时，确认号字段才有效。（可以理解为发送接收到的数据）
标志位(flags): 共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等。具体含义如下:
URG: 紧急指针（urgent pointer）有效。
ACK: 确认号有效。（为了与确认号 ack 区分开，这里采用大写，可以理解为用于确定收到了请求）。
PSH: 接收方应该尽快将这个报文交给应用层。
RST: 重置连接。
SYN: 发起一个新连接。
FIN: 释放一个连接。
```





```js
第一次握手
由浏览器发起，询问服务器我可以和你建立连接吗，可以接收到我的数据吗？

客户端发送一个标志位 SYN、序列号 seq = x 的数据包。发送完成后，客户端进入 SYN_SEND 状态（链接发送状态）。

标志位 SYN 表示要建立连接。（我可以和你建立连接吗）
序列号 seq = x 表示向接收端发送的数据。（可以接收到我的数据吗）


第二次握手
由服务端发起，服务端答应可以建立连接，已收到你的连接请求，能收到我的数据吗？你这数据是这个吗？

服务端发送一个标志位 SYN、标志位 ACK、序列号 seq = y 和 确认号 ack = x + 1 的数据包。发送完成后服务端进入 SYN_RCVD 状态（连接收到状态）。

标志位 SYN 表示要建立连接。（可以建立连接）
标志位ACK 表示收到了请求。（已收到你的连接请求）
序列号 seq = y 表示向接收端发送的数据。（能收到我的数据吗）
确认号 ack = x + 1 表示上一次握手发来的序列号 seq 的值 + 1。（你这数据是这个吗）




第三次握手
由客户端发起，客户端应答已收到你的回复，这是我的数据，这是你的数据。我马上就要发送请求了，准备接收吧。

客户端发送一个标志位为 ACK、确认号 ack = y + 1 和序列号 seq = x + 1 的数据包。

标志位 ACK 表示收到请求。（已收到你的回复）
序列号 seq = x + 1 表示上一次握手发来的 ack 的值。（这是我的数据）
确认号 ack = y + 1表示上一次握手发来的序列号 seq 的值 + 1。（这是你的数据）
将双方的数据发送用于再次验证核对
```


**问题**

为什么需要三次握手，而不是两次或者四次?


> 《计算机网络》中提到目的是为了防止已经失效的连接请求报文段突然又传到服务器，因而产生错误。



**客户端第一次握手发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致发生延迟，一直到 socket 连接释放以后的某个时间节点第一次握手的连接请求报文才到达服务端。本来这是一个早已失效的报文段，但是服务端收到此失效的报文后，会误认为是客户端再次发出的一个新的连接请求，于是服务端就向客户端发出确认报文，表示同意建立连接。**




1: 为什么不是两次握手?

如果不采用三次握手，那么只要服务端发出确认报文（第二次握手）就会认为新的连接已经建立，但是客户端并没有发出建立连接的请求，因此不会向服务端发送数据，服务端没有收到数据就会一直等待，这样服务端就会浪费掉很多资源。如果采用三次握手的话就不会出现这种情况，服务端收到一个过时失效的报文段后，向客户端发出确认报文，此时客户端并没有要求建立连接，所以就不会向服务端发送确认连接的请求，这个时候服务端也能知道连接没有建立。

2: 为什么不是四次握手?

因为通过前三次已经建立了一个可靠的连接，如果再发送第四次确认消息的话，则会浪费资源。


##### 五：HTTPS的TLS四次握手


##### 六：发送HTTP请求


```js
请求报文由请求行、请求头、空行和请求体四个部分组成。

请求行包含请求方法、URL 和版本协议。

POST /getUser?id=ID HTTP/1.1



请求头包含该请求的附加信息，由 key: value 组成，每个请求头独立成行。

HOST: www.XXX.com
User-Agent: Mozilla/5.0(Windows NT 6.1;rv:15.0) Firefox/15.0


请求体可以承载多个请求参数，但是并不是所有请求都会有请求体。

name=test&age=12 // 有 name 和 age 两个参数


```


##### 七：服务器处理并返回 HTTP 报文


```js
响应报文由响应行、响应头部、空行和响应主体三部分组成。


响应行包含协议版本、状态码以及状态码描述

HTTP/1.1 200 OK


状态码规则：


1xx: 指示信息，表示请求已接收，继续处理。

2xx: 成功，表示请求已被成功接收、理解、接受。

    204 表示客户端发送的请求已经在服务端正常处理了，但是没有返回内容。一般情况在只需要从客户端往服务端发送信息，而服务器不需要往客户端发送内容时使用。


3xx: 重定向，要完成请求必须进行更进一步的操作。

    301 永久重定向，在收藏夹中是可以看到网址变化，下次访问的就是新地址

    302 临时重定向，在收藏夹中显示的还是旧地址，下次访问的还是原地址


    304 资源未被修改，已经被请求过一次了，服务端告诉客户端之前请求的资源还有效，可以直接使用本地缓存中的



4xx: 客户端错误，请求有语法错误或请求无法实现。

    400 请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。

    404 资源未找到

    403 没有权限


5xx: 服务器端错误，服务器未能实现合法的请求。
    500 服务器错误
    504 网关超时




响应头包含该响应的附加信息，由 key: value 组成，每个响应头独立成行。


Content-Encoding: gzip
Content-Type: text/html;charset=utf-8



响应体包含了服务器返回给客户端的文本信息，并不是所有响应报文都有响应体。

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <p>this is http response</p>
</body>
</html>
```




##### 八：渲染页面

HTML解析、样式计算、布局、分层、绘制（具体看浏览器渲染原理）

##### 八：断开连接

**tcp四次挥手**


第一次挥手

```js
由浏览器发起，客户端告诉服务器: 我已经不会再给你发送数据了。

用来关闭发送方到接收方的数据传送，发送完成之后客户端进入 FIN_WAIT_1 状态。也就是客户端告诉服务器: 我已经不会再给你发送数据了。但是在标志位为 FIN 的数据包之前发送出去的数据，如果没有收到对应的标志位为 ACK 的确认数据包，客户端依然会重发这些数据。

标志位 FIN 表示释放连接。
标志位 ACK 表示收到了请求，应答上次连接。
FIN_WAIT_1 状态: 表示主动发送关闭连接请求后，在等待另一方的标志位为 FIN 的报文，发送完成之后进入该状态。


第二次挥手

由服务端发起，也就是告诉客户端: 请求已经收到，但是我还没有准备好，请继续等待我释放连接的消息。

服务端防止还有数据没有传输完成，所以并没有发送标志位为 FIN 的释放连接数据包，而是先发送了一个 ACK 确认收到的应答数据包。发送后，服务端进入 CLOSE_WAIT 状态。也就是告诉客户端: 请求已经收到，但是我还没有准备好，请继续等待我释放连接的消息。当客户端收到之后，客户端进入 FIN_WAIT_2 状态。



标志位 ACK 表示收到了请求，应答上次连接。
CLOSE_WAIT 状态: 表示收到对方标志位为 FIN 的报文后，回给对方标志位为 ACK 的报文后的状态，等待关闭，看看自己是否还有数据要发送。
FIN_WAIT_2 状态: 收到另一方发送的标志位为 FIN 的报文后立即进入该状态，此时可能还会接收数据，等待另一方标志位为 FIN 的报文。


第三次挥手


由服务端发起，告诉客户端: 服务器这边数据传输完成，已经准备好关闭连接了。

服务端确认数据已经传输完成，则向客服端发送标志位为 FIN 和 ACK 的数据包，告诉客户端: 服务器这边数据传输完成，已经准备好关闭连接了。服务端发送之后进入 LAST_ACK 状态。


标志位 FIN 表示释放连接。
标志位 ACK 表示收到了请求，应答上次连接。
LAST_ACK 状态: 表示收到对方的发送的标志位为 FIN 的报文之后，回个对方标志位为 ACK 的报文，然后自己也要关闭发送标志位为 FIN 的报文后，等待另一方标志位为 ACK 的报文时的状态。




第四次挥手

由客户端发起，高度服务器: 我这边也准备好关闭连接了，你也可以关闭了。

客户端收到服务器发起的第三次挥手之后，已经知道可以关闭连接了，同时它需要应答服务端的最后一次确认，所以会向服务器发送标志位为 ACK 的数据包。发送成功后客户端进入 TIME_WAIT 状态。服务端收到后正式服务端正式断开连接，进入 CLOSED 状态。同时客户端在发送之后等待 2MSL 后依然没有收到回复则证明服务端已正常关闭，客户端随即也断开连接进入 CLOSED 状态。

标志位 ACK 表示收到了请求，应答上次连接。
MSL(Max Segment Lifetime): 为一个 TCP 报文在 Internet 上的最长生存时间。2MSL 就是两个这样的时间。
CLOSED 状态: 表示连接已经断开。


```


**为什么需要四次挥手，三次不可以吗？**

如果是三次挥手，即省略了第三次挥手，将第三次和第二次合并为一次，也就是在服务器收到客户端发送的关闭请求后，把SYN和ACK包一起发过去。这样会造成服务端和客户端之间还有数据没有传输完成，造成数据的丢失，所以中间的这段时间，等待服务器把剩余的数据传输完成是很有必要的。
