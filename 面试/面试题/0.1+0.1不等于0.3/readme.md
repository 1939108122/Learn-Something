https://www.yuque.com/u21597727/sxil2t/role6d


https://www.xiaolincoding.com/os/1_hardware/float.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B4%9F%E6%95%B0%E8%A6%81%E7%94%A8%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA



0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。

因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。

0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。


精度损失位置： 浮点数保存、对阶运算、加法运算



如何解决：

1: 把小数转成整数进行运算后，再转成对应的小数

2: 0.1 + 0.2 相加后的结果取绝对值减去 0.3,如果小于js里的最小值 Number.EPSILON, 则可认为是相等的。

```js
let a = 0.1, b = 0.2, c = 0.3;

let result = Math.abs(a + b - c) < Number.EPSILON // true 
```